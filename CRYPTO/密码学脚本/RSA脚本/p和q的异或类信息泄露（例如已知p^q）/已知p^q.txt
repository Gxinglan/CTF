from Crypto.Util.number import *
import gmpy2
n = 142518328777474941310863320259497564900997328021676381721739288991345050333027744210675103471136968678518387868994352238849134732031042506006230161171979065365414855084446482402272071787993575997649784943833223779112984325929320026202827651394484673773678719594360270847729610312940223184091675319109292775817
e = 65537
c = 20680945420449890796467908844859179791550010947083240323804567122797989471279243626560829639298034952066186741758822613827156956436929836250070707541583280949078464939312141646124091261005775417661330075209185705431146322455167730607325568659947491273927544572531186424154436059443657453855940553730328634912
leak = 2046025208585503555715936203734835007429347234912683133694269735943515597362652782949952863359497116085349581453413666933145642223278211846376472976963200


a1 = "00" + str(bin(leak)[2:])#确保异或得位数与p，q一致
print(len(a1))
def find(p,q):
	l = len(p)
	tmp0 = p + (512-l)*"0"#根据p的位数替换512
	tmp1 = p + (512-l)*"1"
	tmq0 = q + (512-l)*"0"
	tmq1 = q + (512-l)*"1"
	if(int(tmp0,2)*int(tmq0,2) > n):
		return 
	elif (int(tmp1,2)*int(tmq1,2) < n):
		return
	if l == 512:
		if n%int(p,2)==0:
			pp = int(p,2)
			qq = int(q,2)
			d = gmpy2.invert(e, (pp - 1) * (qq - 1))
			m = pow(c, d, n)
			flag = long_to_bytes(m)
			print(flag)
	
	try:
		if(a1[l] == "1"):
			find(p+"1",q+"0")
			find(p+"0",q+"1")
		else:
			find(p+"0",q+"0")
			find(p+"1",q+"1")
	except:
		pass
tempp = ""
tempq = ""
find(tempp,tempq)