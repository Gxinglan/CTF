import gmpy2
from Crypto.Util.number import *
n = 3966981482745621447573089670807887891869583949641744977093538676656291199447798825799694415879452962971797985511333210005897373869781085298464032669921247755023254086745384065540031416702161055895064799937757947302382867901164507685443200056578802762060508297285923488289877147824029887593666980609508098160584016905857901229877991690184067854045856533280341994975603076157731667728086073206066954357796555871719369778645692150128530639659718300546162750544736819790584115192348977429548842081029357676165797335831504468389547666976748923985828040165872267548769577658691275124686144178021785756107526128685452817903
c = 1194665027563633062248581414560162334231852657988896481199205225478086169508134844926960609919530568608047201361602513231599587985142728739985022871537341396665792181934824177683056725718147641996810309468387559099991432798708480493055930064688470581268403910906634767274835956335855653277313816597112701002136866259658334492071771159534631999698607858634100499972122697477809060312398073023686659910677774113190587685238832554982788701760885981333395017846485726510194874591192291680324719177202811786286323221308310999092370504677807562276354028892789759945040633130992248611355593126431211900348225151260056636038
e = 65537
a=gmpy2.iroot(n,2)[0]
while 1:   #破解出来一组就行了，一般也就一组，挨得很近的话很快就出来了，如果长时间还没出来就可以换方法了，不要指望着他遍历所有的，到死也弄不完。
    B2=a*a-n
    if gmpy2.is_square(B2):
        b=gmpy2.iroot(B2,2)[0]
        p=a+b
        q=a-b
        print(p)
        print(q)
    a+=1