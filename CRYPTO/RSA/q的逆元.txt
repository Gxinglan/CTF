"""
from Crypto.Util.number import getPrime,bytes_to_long
from gmpy2 import invert
from secret import flag

m = bytes_to_long(flag)
p = getPrime(1024)
q = getPrime(1024)
n = p*q
print(invert(q,p))

e = 0x10001
d = invert(e,(p-1)*(q-1))
print(d)

c = pow(m,e,n)
print(c)
"""
import libnum
import gmpy2
 
 
q_1 = 113350138578125471637271827037682321496361317426731366252238155037440385105997423113671392038498349668206564266165641194668802966439465128197299073392773586475372002967691512324151673246253769186679521811837698540632534357656221715752733588763108463093085549826122278822507051740839450621887847679420115044512
d = 27451162557471435115589774083548548295656504741540442329428952622804866596982747294930359990602468139076296433114830591568558281638895221175730257057177963017177029796952153436494826699802526267315286199047856818119832831065330607262567182123834935483241720327760312585050990828017966534872294866865933062292893033455722786996125448961180665396831710915882697366767203858387536850040283296013681157070419459208544201363726008380145444214578735817521392863391376821427153094146080055636026442795625833039248405951946367504865008639190248509000950429593990524808051779361516918410348680313371657111798761410501793645137
c = 619543409290228183446186073184791934402487500047968659800765382797769750763696880547221266055431306972840980865602729031475343233357485820872268765911041297456664938715949124290204230537793877747551374176167292845717246943780371146830637073310108630812389581197831196039107931968703635129091224513813241403591357678410312272233389708366642638825455844282490676862737715585788829936919637988039113463707959069907015464745700766013573282604376277598510224455044288896809217461295080140187509519005245601483583507547733673523120385089098002298314719617693895392148294399937798485146568296114338393548124451378170302291
e = 0x10001
 
# 爆破k   e * d = 1 + k * phi ,phi和d比特位数均为2048，所以e和k的比特位数相近
for k in range(1, e):
    t = e * d - 1  # hint1
    if t % k == 0:
        phi = t // k  # 这里的phi就是 φ
        kp = q_1 * phi - q_1 + 1
        x1 = pow(3, phi, kp) - 1  # 这里3和5换别的数字也行
        x2 = pow(5, phi, kp) - 1
        x = gmpy2.gcd(x1, x2)
        if x.bit_length() == 1024:
            p = x
            q = gmpy2.invert(q_1, p)
            n, phi = p * q, (p - 1) * (q - 1)
            assert d == gmpy2.invert(e, phi)
            m = pow(c, d, n)
            print(libnum.n2s(int(m)))
            break